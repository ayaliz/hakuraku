// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file data.proto (package hakuraku, syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2 } from "@bufbuild/protobuf";

/**
 * @generated from message hakuraku.UMDatabase
 */
export class UMDatabase extends Message<UMDatabase> {
  /**
   * @generated from field: optional string version = 1;
   */
  version?: string;

  /**
   * @generated from field: repeated hakuraku.Chara chara = 2;
   */
  chara: Chara[] = [];

  /**
   * @generated from field: repeated hakuraku.Card card = 9;
   */
  card: Card[] = [];

  /**
   * @generated from field: repeated hakuraku.SupportCard support_card = 11;
   */
  supportCard: SupportCard[] = [];

  /**
   * @generated from field: repeated hakuraku.RaceInstance race_instance = 4;
   */
  raceInstance: RaceInstance[] = [];

  /**
   * @generated from field: repeated hakuraku.Skill skill = 7;
   */
  skill: Skill[] = [];

  /**
   * @generated from field: repeated hakuraku.TextData text_data = 12;
   */
  textData: TextData[] = [];

  /**
   * @generated from field: repeated hakuraku.SingleModeSkillNeedPoint single_mode_skill_need_point = 13;
   */
  singleModeSkillNeedPoint: SingleModeSkillNeedPoint[] = [];

  /**
   * @generated from field: repeated hakuraku.SingleModeRank single_mode_rank = 14;
   */
  singleModeRank: SingleModeRank[] = [];

  constructor(data?: PartialMessage<UMDatabase>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.UMDatabase";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "chara", kind: "message", T: Chara, repeated: true },
    { no: 9, name: "card", kind: "message", T: Card, repeated: true },
    { no: 11, name: "support_card", kind: "message", T: SupportCard, repeated: true },
    { no: 4, name: "race_instance", kind: "message", T: RaceInstance, repeated: true },
    { no: 7, name: "skill", kind: "message", T: Skill, repeated: true },
    { no: 12, name: "text_data", kind: "message", T: TextData, repeated: true },
    { no: 13, name: "single_mode_skill_need_point", kind: "message", T: SingleModeSkillNeedPoint, repeated: true },
    { no: 14, name: "single_mode_rank", kind: "message", T: SingleModeRank, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UMDatabase {
    return new UMDatabase().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UMDatabase {
    return new UMDatabase().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UMDatabase {
    return new UMDatabase().fromJsonString(jsonString, options);
  }

  static equals(a: UMDatabase | PlainMessage<UMDatabase> | undefined, b: UMDatabase | PlainMessage<UMDatabase> | undefined): boolean {
    return proto2.util.equals(UMDatabase, a, b);
  }
}

/**
 * @generated from message hakuraku.Chara
 */
export class Chara extends Message<Chara> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * @generated from field: optional string cast_name = 3;
   */
  castName?: string;

  constructor(data?: PartialMessage<Chara>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.Chara";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "cast_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Chara {
    return new Chara().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Chara {
    return new Chara().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Chara {
    return new Chara().fromJsonString(jsonString, options);
  }

  static equals(a: Chara | PlainMessage<Chara> | undefined, b: Chara | PlainMessage<Chara> | undefined): boolean {
    return proto2.util.equals(Chara, a, b);
  }
}

/**
 * @generated from message hakuraku.Card
 */
export class Card extends Message<Card> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  constructor(data?: PartialMessage<Card>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.Card";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Card {
    return new Card().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Card {
    return new Card().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Card {
    return new Card().fromJsonString(jsonString, options);
  }

  static equals(a: Card | PlainMessage<Card> | undefined, b: Card | PlainMessage<Card> | undefined): boolean {
    return proto2.util.equals(Card, a, b);
  }
}

/**
 * @generated from message hakuraku.SupportCard
 */
export class SupportCard extends Message<SupportCard> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * @generated from field: optional int32 chara_id = 3;
   */
  charaId?: number;

  constructor(data?: PartialMessage<SupportCard>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.SupportCard";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "chara_id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SupportCard {
    return new SupportCard().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SupportCard {
    return new SupportCard().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SupportCard {
    return new SupportCard().fromJsonString(jsonString, options);
  }

  static equals(a: SupportCard | PlainMessage<SupportCard> | undefined, b: SupportCard | PlainMessage<SupportCard> | undefined): boolean {
    return proto2.util.equals(SupportCard, a, b);
  }
}

/**
 * @generated from message hakuraku.RaceInstance
 */
export class RaceInstance extends Message<RaceInstance> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * @generated from field: optional int32 distance = 3;
   */
  distance?: number;

  /**
   * @generated from field: optional hakuraku.RaceInstance.GroundType ground_type = 4;
   */
  groundType?: RaceInstance_GroundType;

  constructor(data?: PartialMessage<RaceInstance>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.RaceInstance";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "distance", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "ground_type", kind: "enum", T: proto2.getEnumType(RaceInstance_GroundType), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RaceInstance {
    return new RaceInstance().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RaceInstance {
    return new RaceInstance().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RaceInstance {
    return new RaceInstance().fromJsonString(jsonString, options);
  }

  static equals(a: RaceInstance | PlainMessage<RaceInstance> | undefined, b: RaceInstance | PlainMessage<RaceInstance> | undefined): boolean {
    return proto2.util.equals(RaceInstance, a, b);
  }
}

/**
 * @generated from enum hakuraku.RaceInstance.GroundType
 */
export enum RaceInstance_GroundType {
  /**
   * @generated from enum value: UNKNOWN_GROUND_TYPE = 0;
   */
  UNKNOWN_GROUND_TYPE = 0,

  /**
   * @generated from enum value: TURF = 1;
   */
  TURF = 1,

  /**
   * @generated from enum value: DIRT = 2;
   */
  DIRT = 2,
}
// Retrieve enum metadata with: proto2.getEnumType(RaceInstance_GroundType)
proto2.util.setEnumType(RaceInstance_GroundType, "hakuraku.RaceInstance.GroundType", [
  { no: 0, name: "UNKNOWN_GROUND_TYPE" },
  { no: 1, name: "TURF" },
  { no: 2, name: "DIRT" },
]);

/**
 * @generated from message hakuraku.Skill
 */
export class Skill extends Message<Skill> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional string name = 2;
   */
  name?: string;

  /**
   * @generated from field: optional sint32 grade_value = 3;
   */
  gradeValue?: number;

  /**
   * enum SingleModeDefine.SkillTag
   *    RunningStyleBegin = 100;
   *    Nige = 101;
   *    Senko = 102;
   *    Sashi = 103;
   *    Oikomi = 104;
   *    RunningStyleEnd = 199;
   *    DistanceBegin = 200;
   *    Short = 201;
   *    Mile = 202;
   *    Middle = 203;
   *    Long = 204;
   *    DistanceEnd = 299;
   *    SPEED = 401;
   *    STAMINA = 402;
   *    POWER = 403;
   *    GUTS = 404;
   *    WIZ = 405;
   *    DOWN = 406;
   *    SPECIAL = 407;
   *    GroundBegin = 500;
   *    Turf = 501;
   *    Dirt = 502;
   *    GroundEnd = 599;
   *    ScenarioBegin = 800;
   *    ScenarioEnd = 899;
   *
   * @generated from field: repeated string tag_id = 4;
   */
  tagId: string[] = [];

  /**
   * @generated from field: optional int32 rarity = 5;
   */
  rarity?: number;

  constructor(data?: PartialMessage<Skill>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.Skill";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "grade_value", kind: "scalar", T: 17 /* ScalarType.SINT32 */, opt: true },
    { no: 4, name: "tag_id", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "rarity", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Skill {
    return new Skill().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Skill {
    return new Skill().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Skill {
    return new Skill().fromJsonString(jsonString, options);
  }

  static equals(a: Skill | PlainMessage<Skill> | undefined, b: Skill | PlainMessage<Skill> | undefined): boolean {
    return proto2.util.equals(Skill, a, b);
  }
}

/**
 * @generated from message hakuraku.TextData
 */
export class TextData extends Message<TextData> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional int32 category = 2;
   */
  category?: number;

  /**
   * @generated from field: optional int32 index = 3;
   */
  index?: number;

  /**
   * @generated from field: optional string text = 4;
   */
  text?: string;

  constructor(data?: PartialMessage<TextData>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.TextData";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "category", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "index", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextData {
    return new TextData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextData {
    return new TextData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextData {
    return new TextData().fromJsonString(jsonString, options);
  }

  static equals(a: TextData | PlainMessage<TextData> | undefined, b: TextData | PlainMessage<TextData> | undefined): boolean {
    return proto2.util.equals(TextData, a, b);
  }
}

/**
 * @generated from message hakuraku.SingleModeSkillNeedPoint
 */
export class SingleModeSkillNeedPoint extends Message<SingleModeSkillNeedPoint> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional int32 need_skill_point = 2;
   */
  needSkillPoint?: number;

  /**
   * @generated from field: optional int32 status_type = 3;
   */
  statusType?: number;

  /**
   * @generated from field: optional int32 status_value = 4;
   */
  statusValue?: number;

  /**
   * @generated from field: optional int32 solvable_type = 5;
   */
  solvableType?: number;

  constructor(data?: PartialMessage<SingleModeSkillNeedPoint>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.SingleModeSkillNeedPoint";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "need_skill_point", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "status_type", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 4, name: "status_value", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 5, name: "solvable_type", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SingleModeSkillNeedPoint {
    return new SingleModeSkillNeedPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SingleModeSkillNeedPoint {
    return new SingleModeSkillNeedPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SingleModeSkillNeedPoint {
    return new SingleModeSkillNeedPoint().fromJsonString(jsonString, options);
  }

  static equals(a: SingleModeSkillNeedPoint | PlainMessage<SingleModeSkillNeedPoint> | undefined, b: SingleModeSkillNeedPoint | PlainMessage<SingleModeSkillNeedPoint> | undefined): boolean {
    return proto2.util.equals(SingleModeSkillNeedPoint, a, b);
  }
}

/**
 * @generated from message hakuraku.SingleModeRank
 */
export class SingleModeRank extends Message<SingleModeRank> {
  /**
   * @generated from field: optional int32 id = 1;
   */
  id?: number;

  /**
   * @generated from field: optional int32 min_value = 2;
   */
  minValue?: number;

  /**
   * @generated from field: optional int32 max_value = 3;
   */
  maxValue?: number;

  constructor(data?: PartialMessage<SingleModeRank>) {
    super();
    proto2.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto2 = proto2;
  static readonly typeName = "hakuraku.SingleModeRank";
  static readonly fields: FieldList = proto2.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "min_value", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 3, name: "max_value", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SingleModeRank {
    return new SingleModeRank().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SingleModeRank {
    return new SingleModeRank().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SingleModeRank {
    return new SingleModeRank().fromJsonString(jsonString, options);
  }

  static equals(a: SingleModeRank | PlainMessage<SingleModeRank> | undefined, b: SingleModeRank | PlainMessage<SingleModeRank> | undefined): boolean {
    return proto2.util.equals(SingleModeRank, a, b);
  }
}

